<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile AI Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        #status { 
            position: absolute; top: 10px; left: 10px; color: #0f0; 
            font-family: monospace; font-size: 12px; z-index: 10;
            background: rgba(0,0,0,0.6); padding: 5px;
        }
        canvas { display: block; }
        video { display: none; }
    </style>
</head>
<body>
    
    <div id="status">Status: Waiting for click...</div>
    <br>
    <div style="color: azure; position: relative; top: 100px; left: 10px;">
        AI Particle tracker by PRAYASH
    </div>
    <button id="start" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); padding:20px; z-index:100;">START CAMERA</button>
    <video id="webcam" playsinline></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const status = document.getElementById('status');
        const startBtn = document.getElementById('start');
        let scene, camera, renderer, points;
        
        // Lower particle count for mobile performance
        const pCount = window.innerWidth < 600 ? 5000 : 12000;

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: false }); // Antialias off for mobile speed
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount*3; i++) pos[i] = (Math.random()-0.5)*10;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            
            points = new THREE.Points(geo, new THREE.PointsMaterial({color: 0x00ffff, size: 0.05}));
            scene.add(points);

            // Touch Support for Phone
            window.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                points.position.x = (touch.clientX / window.innerWidth - 0.5) * 10;
                points.position.y = -(touch.clientY / window.innerHeight - 0.5) * 10;
            });
        }

        async function setupAI() {
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0 }); // Complexity 0 is faster for phones
            
            hands.onResults((res) => {
                if(res.multiHandLandmarks.length > 0) {
                    const h = res.multiHandLandmarks[0][9];
                    points.position.x = (h.x - 0.5) * -10;
                    points.position.y = -(h.y - 0.5) * 10;
                    status.innerText = "Status: Tracking Hand";
                }
            });

            const vid = document.getElementById('webcam');
            const cam = new Camera(vid, {
                onFrame: async () => { await hands.send({image: vid}); },
                width: 480, height: 360 // Lower resolution for mobile speed
            });
            await cam.start();
            status.innerText = "Status: Camera Running";
        }

        startBtn.onclick = () => {
            startBtn.style.display = 'none';
            init();
            setupAI();
            (function animate() {
                requestAnimationFrame(animate);
                points.rotation.y += 0.01;
                renderer.render(scene, camera);
            })();
        };

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
